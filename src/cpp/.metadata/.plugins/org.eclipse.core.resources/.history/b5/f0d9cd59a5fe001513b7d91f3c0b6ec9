#include <string>  // for memcpy
#include <stdlib.h>  // for rand
#include <iterator>
#include <time.h>
#include <map>
#include <set>
#include <algorithm>
#include <iomanip>
#include <unistd.h>
#include "sbbHP.h"
#include <sys/stat.h>

#define MEAN_OUT_PROP 1.0

/********************************************************************************************/
sbbHP::sbbHP(int seed)
{
	team_count = 10000*seed;
	learner_count = 10000*seed;
	point_count = 10000*seed;

	_seed = 0; //will be set to port # later
	_id = -1;
	_simTime = 0;
}

sbbHP::~sbbHP()
{
	;
}

/*********************************************************************************************/
void sbbHP::adjustIds(int m){
	set < learner * > :: iterator leiter, leiterEnd;
	for(leiter = _L.begin(); leiter != _L.end(); leiter++)
		(*leiter)->setId((*leiter)->id()*m);
	set < team * > :: iterator teiter, teiterEnd;
	for(teiter = _M.begin(); teiter != _M.end(); teiter++){
		(*teiter)->id((*teiter)->id()*m);

	}
}
/********************************************************************************************/
void sbbHP::checkRefCounts(const char *msg){
	int nrefs = 0;
	int sumTeamSizes = 0;
	set < learner * > :: iterator leiter, leiterEnd;
	set < team * > :: iterator teiter, teiterEnd;

	for(leiter = _L.begin(); leiter != _L.end(); leiter++)
		nrefs += (*leiter)->refs();
	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
		sumTeamSizes += (*teiter)->size();
	if(sumTeamSizes != nrefs){
		cerr << "nrefs " << nrefs << " sumTeamSize " << sumTeamSizes << endl;
		die(__FILE__, __FUNCTION__, __LINE__, msg);
	}
}
/********************************************************************************************/
void sbbHP::cleanup(long t,
		long level, bool prune)
{
	/* Delete points marked for deletion. */
	/* Delete learners that are no longer referenced. */
	/* Delete cached outcomes/margins for deleted points. */

	set < point * > :: iterator poiter, poiterend;
	set < team *, teamIdComp > :: iterator teiter, teiterbegin, teiterend;
	set < learner * > :: iterator leiter, leiterend;

	vector < point * > pointvec;
	vector < learner * > learnervec;

	size_t size;
	size_t i;

	/* Collect points into pointvec. */

	for(poiter = _P.begin(), poiterend = _P.end();
			poiter != poiterend; poiter++)
		pointvec.push_back(*poiter);

	/* Delete marked points. */

	size = pointvec.size();
	for(i = 0, teiterbegin = _M.begin(), teiterend = _M.end(); i < size; i++)
	{
		if(pointvec[i]->marked() == true)
		{
			/* This point is marked for deletion. */

			/* Delete outcomes and margins for this point. */

			for(teiter = teiterbegin; teiter != teiterend; teiter++)
			{
				(*teiter)->deleteOutcome(pointvec[i]);
				//(*teiter)->deleteMargin(pointvec[i]);
			}

			/* Get rid of this point. */

			_P.erase(pointvec[i]);

		}
	}

	// Prune the learners, check _omega if this is not the last generation.
	//if (prune == true)
	//   pruneLearners(t != _t);
	pruneLearners(false);


	// Collect learners into learnervec.

	for(leiter = _L.begin(), leiterend = _L.end();
			leiter != leiterend; leiter++)
		learnervec.push_back(*leiter);

	// Delete learners with zero references.

	size = learnervec.size();
	for(size_t i = 0; i < size; i++)
	{
		if(learnervec[i]->refs() == 0)
		{
			// Zero references, delete this learner.
			_L.erase(learnervec[i]);
			delete learnervec[i];
		}
	}

#ifdef MYDEBUG
	int sumTeamSizes=0;
	int nrefs = 0;
	int sumNumOutcomes = 0;

	cout << "sbbHP::cleanup ";
	//cout << _P.size() << " points, " << _L.size() << " learners, " << _M.size() << " teams";
	cout << _L.size() << " learners, " << _M.size() << " teams";
	for(teiter = _M.begin(), sumTeamSizes = sumNumOutcomes = 0; teiter != _M.end(); teiter++)
	{
		sumTeamSizes += (*teiter)->size();
		sumNumOutcomes += (*teiter)->numOutcomes(_TRAIN_PHASE);
	}

	for(leiter = _L.begin(), nrefs = 0; leiter != _L.end(); leiter++)
		nrefs += (*leiter)->refs();

	cout << ", sumTeamSizes " << sumTeamSizes << ", nrefs " << nrefs << ", sumNumOutcomes " << sumNumOutcomes;
	cout << endl;

	if(sumTeamSizes != nrefs)// || sumNumOutcomes != (_Msize - _Mgap) * (_Psize - _Pgap))
		die(__FILE__, __FUNCTION__, __LINE__, "something messed up during cleanup");

#endif
}

/***********************************************************************************************************/
void sbbHP::clear()
{
	/* Free any allocated memory before exit. */

	_M.clear();
	_L.clear();
	_teamMap.clear();
}

/********************************************************************************************/
void sbbHP::debugRefs(long t,
		long level)
{
	set < team *, teamIdComp > :: iterator teiter, itBegin, teiterEnd;
	set < learner * > :: iterator leiter, leiterEnd;

	int nrefs = 0;
	int sumTeamSizes = 0;
	int sumNumOutcomes = 0;

	cout << "sbbHP::debugRefs ";
	//cout << _P.size() << " points, " << _L.size() << " learners, " << _M.size() << " teams";
	cout << _L.size() << " learners, " << _M.size() << " teams";
	for(teiter = _M.begin(), sumTeamSizes = sumNumOutcomes = 0; teiter != _M.end(); teiter++)
	{
		sumTeamSizes += (*teiter)->size();
		sumNumOutcomes += (*teiter)->numOutcomes(_TRAIN_PHASE);
	}

	for(leiter = _L.begin(), nrefs = 0; leiter != _L.end(); leiter++)
		nrefs += (*leiter)->refs();

	cout << ", sumTeamSizes " << sumTeamSizes << ", nrefs " << nrefs << ", sumNumOutcomes " << sumNumOutcomes;
	cout << endl;

	if(sumTeamSizes != nrefs)// || sumNumOutcomes != (_Msize - _Mgap) * (_Psize - _Pgap))
		die(__FILE__, __FUNCTION__, __LINE__, "something messed up during cleanup");

	//#endif
}

/********************************************************************************************
 * No diversity.
 */
void sbbHP::diversityMode0(long t, long level){
	set < team *, teamIdComp > :: iterator teiter, teiterend;

	for(teiter = _M.begin(); teiter != _M.end(); teiter++){
		(*teiter)->score((*teiter)->getMeanOutcome(_fitMode,_TRAIN_PHASE,MEAN_OUT_PROP));
		(*teiter)->fit((*teiter)->getMeanOutcome(_fitMode,_TRAIN_PHASE,MEAN_OUT_PROP));
	}
	//fit normalized wrt population
	//vector < team * > teams;
	//for(teiter = _M.begin(); teiter != _M.end(); teiter++)
	//  teams.push_back(*teiter);
	//     
	//
	//double meanOutMax = 0;
	//double meanOutMin = HUGE_VAL;

	//for(int i = 0; i < teams.size(); i++){
	//   double meanOut = teams[i]->getMeanOutcome(_TRAIN_REWARD,_TRAIN_PHASE);
	//   if (meanOut < meanOutMin)
	//      meanOutMin = meanOut;
	//   if (meanOut > meanOutMax)
	//      meanOutMax = meanOut;
	//}
	////set normalized fit (score just equal to fit)
	//for(int i = 0; i < teams.size(); i++){
	//   teams[i]->fit((teams[i]->getMeanOutcome(_TRAIN_REWARD,_TRAIN_PHASE)-meanOutMin)/(meanOutMax-meanOutMin));
	//   teams[i]->score((teams[i]->getMeanOutcome(_TRAIN_REWARD,_TRAIN_PHASE)-meanOutMin)/(meanOutMax-meanOutMin));
	//}
}

/*********************************************************************************************
 * Helper struct for distance comparisons.
 */

struct distanceInstance {
	double distance;
	bool fromArchive;
	distanceInstance(double d,bool a):distance(d),fromArchive(a) {}
} ;

bool compareByDistance(const distanceInstance &a, const distanceInstance &b)
{
	return a.distance < b.distance;
}
/***********************************************************************************************************/
//Currently Ms. Pac-Man specific
point * sbbHP::genPoint(long gtime,
		point *p1,
		point *p2)
{
	int phase;
	vector < double > pState;

	/* Start by copying one of the parents. */

	if(drand48() < 0.5){
		p1->pointState(pState);
		phase = p1->phase();
	}
	else{
		p2->pointState(pState);
		phase = p2->phase();
	}

	double m;
	for (size_t i = 0; i < pState.size(); i++){
		do
		{
			m = 0.1 * gasdev();
		}while(pState[i] + m < 0 || pState[i] + m > 1);

		pState[i] = pState[i] + m;
	}

	return new point(gtime, phase, point_count++, pState);
}
/********************************************************************************************/
void sbbHP::genPoints(long t)
{
	//while(_P.size() < _Psize)
	//	_P.insert(initUniformPointGeneric(-1, point_count++, _TRAIN_PHASE));
	
		/* Generate points selecting parents using roulette wheel selection. */
	
		vector < point * > points;
		set < point * > :: iterator poiter;
	
		vector < double > wheel;
		double denom;
		double sum;
		double drnd;
		size_t i;
	
		set < long > usedIds;
	
		for(poiter = _P.begin(); poiter != _P.end(); poiter++)
			points.push_back(*poiter);
	
		for(denom = 0, i = 0; i < points.size(); i++)
		{
			wheel.push_back(points[i]->slice());
			denom += wheel.back();
		}
	
	#ifdef MYDEBUG
		cout << "sbbHP::genPoints " << t << " denom " << denom << " slices" << vecToStr(wheel) << endl;
	#endif
	
		if(denom < 1e-5) /* All get 0 reward, let each have the same amount of pie. */
		{
			wheel.clear();
			wheel.insert(wheel.begin(), points.size(), 1);
			denom = points.size();
		}
	
		for(sum = 0, i = 0; i < points.size(); i++)
		{
			sum += wheel[i];
			wheel[i] = sum / denom;
		}
	
	#ifdef MYDEBUG
		cout << "sbbHP::genPoints " << t << " thresholds" << vecToStr(wheel) << endl;
	#endif
	
		while(_P.size() < _Psize)
		{
			if(drand48() < 0.9)
			{
				drnd = drand48();
	
				for(i = 0; i < wheel.size() && drnd > wheel[i]; i++)
					;
	
				if(i == wheel.size())
					i--;
	
				_P.insert(genPoint(t, points[i], points[i]));
			}
			else
			{
				_P.insert(initUniformPointGeneric(-1, point_count++, _TRAIN_PHASE));
			}
		}
}
/********************************************************************************************/
void sbbHP::genTeams(long t,
		long level)
{
	vector < team * > parent;
	int psize;

	team *pm;
	team *cm;

	vector < learner * > lpop;

	parent.insert(parent.begin(), _M.begin(), _M.end());

	psize = parent.size();
	lpop.insert(lpop.begin(), _L.begin(), _L.end());
	//std::pair<std::set<team *, teamIdComp>::iterator,bool> ret;
	while(_M.size() < _Msize)
	{
		pm = parent[(int) (drand48() * psize)];
		genTeams(t, pm, &cm, lpop, level);
		_M.insert(cm);
	}

	setRoots();
}

/********************************************************************************************/
void sbbHP::genTeams(long t,
		team *pm,
		team **cm,
		vector < learner * > &lpop,
		long level)
{
	set < learner * > plearners;
	set < learner * > clearners;

	set < learner * > :: iterator leiter;

	vector < learner * > learnervec;

	int i;

	double b;

	learner *lr;

	bool changedL;
	bool changedM;

	size_t lsize;

	lsize = lpop.size();

	pm->members(&plearners);
	*cm = new team(level, t, team_count++);

	for(leiter = plearners.begin(); leiter != plearners.end(); leiter++)
		(*cm)->addLearner(*leiter);

	learnervec.insert(learnervec.begin(), plearners.begin(), plearners.end());

	vector < team * > teams;
	set < team *, teamIdComp > :: iterator teiter, teiterend;

	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
		teams.push_back(*teiter);



	// Remove learners.
	for(b = 1.0; drand48() < b && (*cm)->size() > 2; b = b * _pmd)
	{
		do
		{
			i = (int) (drand48() * learnervec.size());
		}
		while(learnervec[i]->action() < 0 && (*cm)->numAtomic() < 2);//never remove the fail-safe atomic learner
		(*cm)->removeLearner(learnervec[i]);

		clearners.clear();//this could maybe move into the members function
		(*cm)->members(&clearners);
		learnervec.clear();
		learnervec.insert(learnervec.begin(), clearners.begin(), clearners.end());
	}

	// Add learners.
	for(b = 1.0; drand48() < b && (*cm)->size() < _omega && (*cm)->size() < lsize; b = b * _pma)
	{
		do
		{
			i = (int) (drand48() * lsize);
		}
		while(lpop[i]->action() == (*cm)->id() || (*cm)->addLearner(lpop[i]) == false); //avoid loop-backs
	}

	// Mutate learners.

	clearners.clear();
	(*cm)->members(&clearners);

	changedM = false;

	do
	{
		for(leiter = clearners.begin(); leiter != clearners.end(); leiter++)
		{
			if(drand48() < _pmm)
			{
				changedM = true;

				(*cm)->removeLearner(*leiter);

				lr = new learner(t, **leiter, learner_count++);

				do
				{
					changedL = lr->muBid(_pBidDelete, _pBidAdd, _pBidSwap, _pBidMutate, _maxProgSize);
				}
				while(changedL == false);

				genUniqueLearner(lr, _L); /* Make sure bid unique. */

				if(drand48() < _pmn){
					if (_M.size() > 0 && (lr->action() < 0 && (*cm)->numAtomic() < 2) ? drand48() < _pAtomic : true) //always mutate the fail-safe atomic learner to another atomic
						lr->muAction(-1 - ((long) (drand48() * numAtomicActions()))); //atomic actions are negatives -1 down to -numActions(0)
					else{
						long a;

						do{
							a = (long) (drand48() * teams.size()); //meta-actions are between 0 and _M.size() - 1
						} while(teams[a]->id() == (*cm)->id());//avoid loop-backs
						lr->muAction(teams[a]->id());
					}
				}

				(*cm)->addLearner(lr);
				_L.insert(lr);
			}
		}
	}
	while(changedM == false);

	/* Increment references. */

	clearners.clear();
	(*cm)->members(&clearners);

	for(leiter = clearners.begin(); leiter != clearners.end(); leiter++)
		(*leiter)->refInc();

	(*cm)->parentScore(pm->fit());
	(*cm)->addAncestor(pm->id());

	//copy all parents ancestors
	vector <long> parentAncestors;
	pm->getAllAncestors(parentAncestors);
	for (size_t i = 0; i < parentAncestors.size(); i++)
		(*cm)->addAncestor(parentAncestors[i]);
}

/********************************************************************************************/
// Keep altering 'lr' as long as its bid profile is the same as the bid
//   profile of one of the learners in 'learners'. 
void sbbHP::genUniqueLearner(learner *lr,
		set < learner * > learners)
{
	vector < double > profile;
	set < learner * > :: iterator leiter;

	vector < double > state;

	size_t i;

	bool stop = false;

	bool changedL;

	double *REG = (double *) alloca(REGISTERS * sizeof(double));

#ifdef MYDEBUG
	for(i = 0, leiter = learners.begin(); leiter != learners.end(); leiter++, i++)
	{
		(*leiter)->getProfile(profile);
		cout << "sbbHP::genUniqueLearner " << lr->id() << " " << i << " " << (*leiter)->id() << " profile" << vecToStr(profile) << endl;
	}
#endif

	while(stop == false)
	{
		profile.clear();

		// Create new profile.

		for(i = 0; i < _profilePointsFIFO.size(); i++)
		{
			_profilePointsFIFO[i]->behaviouralState(state);
			profile.push_back(lr->bid(&state[0], REG));
		}

#ifdef MYDEBUG
		cout << "sbbHP::genUniqueLearner " << lr->id() << " profile" << vecToStr(profile);
#endif

		if(profile.size() != _profilePointsFIFO.size())
			die(__FILE__, __FUNCTION__, __LINE__, "bad profile size");

		for(leiter = learners.begin(); leiter != learners.end(); leiter++)
			if((*leiter)->isProfileEqualTo(profile))
				break;

		if(leiter == learners.end())
		{
			//Not a duplicate bidder.

#ifdef MYDEBUG
			cout << " is unique" << endl;
#endif

			stop = true;
		}
		else
		{
			// Duplicate bidder.

#ifdef MYDEBUG
			cout << " is a duplicate of " << (*leiter)->id() << endl;
#endif

			do
			{
				changedL = lr->muBid(_pBidDelete, _pBidAdd, _pBidSwap, _pBidMutate, _maxProgSize);
			}
			while(changedL == false);
		}
	}

	lr->setProfile(profile);
}


/********************************************************************************************/
void sbbHP::getBestTeam(long t, long level,int phase){
	set < team * , teamIdComp> :: iterator teiter, teiterend;
	double maxMeanOut = -HUGE_VAL;
	double meanOut = 0;

	oss.str("");
	currentChampion = (*_M.begin());
	for(teiter = _M.begin(); teiter != _M.end(); teiter++){
		if ((*teiter)->numOutcomes(phase) > _episodesPerGeneration && (*teiter)->numOutcomes(_TEST_PHASE) == 0){ //only consider hosts that are older than 1 generation and not yet tested
			meanOut = (*teiter)->getMeanOutcome(_TRAIN_REWARD,phase,MEAN_OUT_PROP);
			oss << "sbb::getBestTeamAll phase " << phase << " l " << level << " t " << t << " tm " << (*teiter)->id();
			oss << " score " << meanOut << " numOutcome " << (*teiter)->numOutcomes(phase) << endl;
			if (meanOut > maxMeanOut){
				currentChampion = (*teiter);
				maxMeanOut = meanOut;
			}
		}
	}
	set <team*> visitedTeams;
	oss << "sbb::getBestTeam l " << level << " t " << t << " " << currentChampion->toString("maxteam",_teamMap, visitedTeams);
	cout << oss.str();
	oss.str("");
	oss << "sbb::getBestTeam best l " << level << " t " << t << " meanOutcome " <<  maxMeanOut;
	oss << " age " << t - currentChampion->gtime();
	oss << " " << *currentChampion << endl;
	cout << oss.str();
	oss.str("");

	//cout.precision(numeric_limits< double >::digits10+1);
	//set < team * , teamIdComp> :: iterator teiter, teiterend;
	//paretoRanking(t,level,_VALIDATION_PHASE);
	//set <team *, teamScoreLexicalCompare> teams;
	//for(teiter = _M.begin(); teiter != _M.end(); teiter++){
	//   //(*teiter)->score((*teiter)->getMeanOutcome(_TEST_REWARD,phase));
	//   teams.insert(*teiter);
	//}

	//currentChampion = *(teams.begin());

	//cout << "getBestTeamRanking phase " << phase << " l " << level << " t " << t;
	//set < long > policyFeatures;
	//int numLearnersInPolicy;
	//for(set<team*, teamScoreLexicalCompare > :: iterator it = teams.begin(); it != teams.end();++it){
	//   numLearnersInPolicy = (*it)->policyFeatures(policyFeatures);
	//   cout << std::fixed << " [" << (*it)->score();
	//   cout << "," << (*it)->asize() << "," << numLearnersInPolicy << "," << policyFeatures.size() << "," << (*it)->gtime();
	//   cout << "," << (*it)->id() << "," << (*it)->lastCompareFactor() << "]";
	//   policyFeatures.clear();
	//}
	//cout << endl;

	//cout << std::fixed << "sbb::getBestTeam best l " << level << " t " << t << " score " <<  currentChampion->score();;
	//cout << " age " << t - currentChampion->gtime();
	//cout << " " << *currentChampion << endl;
}
/********************************************************************************************/
void sbbHP::initPoints()
{
	set < long > usedIds;

	while(_P.size() < _Psize - _Pgap)
		_P.insert(initUniformPointGeneric(-1, point_count++, _TRAIN_PHASE));
}

/********************************************************************************************/
void sbbHP::initTeams(long level)
{
	long a1, a2;
	team *m;
	learner *l;

	// Number of teams to initialize.
	int keep = _Msize - _Mgap;

	int tc;

	size_t i, j, k;

	set < team * > :: iterator teiter;

	vector < learner * > learnervec;

	size_t size;

	set < learner * > lused;
	set < learner * > :: iterator leiter;

	vector< team* > teams;

	size_t tsize = 10;

	for(tc = 0; tc < keep; tc++)
	{

		// Get two different actions.

		//a1 is the fail-safe atomic
		a1 = -1 - ((long) (drand48() * numAtomicActions())); //atomic actions are negatives -1 to -numAtomicActions()

		do
		{
			if (_M.size() > 0 ? drand48() < _pAtomic : true)
				a2 = -1 - ((long) (drand48() * numAtomicActions())); //atomic actions are negatives -1 to -numAtomicActions()
			else{
				a2 = (long) (drand48() * _M.size()); //meta-actions are between 0 and _M.size()
				a2 = teams[a2]->id();
			}
		} while (a1 == a2);

		// Create a new team containing two learners.

		m = new team(level, 1, team_count++);

		l = new learner(1, a1, _maxProgSize, _dimB, learner_count++);
		genUniqueLearner(l, _L);  //Make sure bid unique.
		m->addLearner(l);
		l->refInc();
		_L.insert(l);

		l = new learner(1, a2, _maxProgSize, _dimB, learner_count++);
		genUniqueLearner(l, _L); // Make sure bid unique.
		m->addLearner(l);
		l->refInc();
		_L.insert(l);

		_M.insert(m);
		teams.push_back(m);
#ifdef MYDEBUG
		cout << "sbbHP::initTeams added " << *m << endl;
#endif
	}

	// Mix the learners up.
	learnervec.insert(learnervec.begin(), _L.begin(), _L.end());

	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
	{
		// Get the learners in the team.
		lused.clear();
		(*teiter)->members(&lused);
		// Get the final team size, make sure not too big.
		size = (int) (drand48() * (5 + 1));  
		//size = (int) (drand48() * (_omega + 1));
		if(size > learnervec.size() - 2)
			size = learnervec.size() - 2;

		// Build the team up.
		size_t numTries = learnervec.size()*2;
		size_t t = 0;
		while((*teiter)->size() < size && t <= numTries)
		{
			// Get first learner, make sure not in the team or loop-back.

			i = (int) (drand48() * learnervec.size());

			while(lused.find(learnervec[i]) != lused.end() || learnervec[i]->action() == (*teiter)->id())
				i = (i + 1) % learnervec.size();

			for(k = 0; k < tsize; k++)
			{
				// Get another learner, make sure not in the team or loop-back.

				j = (int) (drand48() * learnervec.size());

				while(lused.find(learnervec[j]) != lused.end() || learnervec[i]->action() == (*teiter)->id())
					j = (j + 1) % learnervec.size();

				// Pick second learner if it has fewer refs.
				if(learnervec[j]->refs() < learnervec[i]->refs())
					i = j;

			}
			(*teiter)->addLearner(learnervec[i]);
			lused.insert(learnervec[i]);
			learnervec[i]->refInc();
		}
	}

	setRoots();
}

/*******************************************************************************************/
point * sbbHP::initUniformPointGeneric(long gtime, long id, int phase)
{
	vector < double > pState;
	vector < double > bState;

	for (int i = 0; i < _dimP; i++)
		pState.push_back(drand48());
	for (int i = 0; i < _dimB; i++)
		bState.push_back(drand48());
	vector<double> rewards;
	rewards.push_back(0);
	rewards.push_back(0);
	rewards.push_back(0);

	return new point(gtime, phase, id, pState, bState, rewards);
}

/***********************************************************************************************************/

// The evaluation vector, _mEvaluate, stores one team pointer for each evaluation that needs to take place at 
// this point in time. 
//
// If a team needs to be evaluated 10 times, _mEvaluate will store 10 pointers to that team. The evaluation
// routine can then loop through _mEvaluate, running each team (pointer) on the task.
// Which teams are included in the evaluation, and how many times, is dictated by their stored outcomes and
// the  phase (training, validation, test, or replay).
//
// When sbbHP is part of a "satelite" agent that only exists for a single evaluation round, as is the
// case in some domains such as Robocup, no outcome history is present and thus tmpNumOutcomes is used 
// instead. 

void sbbHP::makeEvaluationVector(int t, int phase, bool useTmpNumOutcomes, int playGames){
	set < team * , teamIdComp > :: iterator teiter;
	_mEvaluate.clear();
	int numOuts = 0;
	int fill = 0;
	switch (phase){
		case _TRAIN_PHASE:
			for(teiter = _M.begin(); teiter != _M.end(); teiter++){
				if ((*teiter)->root()){
					if (useTmpNumOutcomes==false)
						numOuts = (*teiter)->numOutcomes(phase);
					else
						numOuts = (*teiter)->tmpNumOutcomes();
					if (numOuts < _numStoredOutcomesPerHost[phase]){
						fill = min((int)(_numStoredOutcomesPerHost[phase] - numOuts),(int)_episodesPerGeneration);
						for (int i = 0; i < fill; i++)
							_mEvaluate.push_back(*teiter);
					}
					//else if((*teiter)->getMeanOutcome(_TRAIN_REWARD,_TRAIN_PHASE) < _maxTrainingReward)
					//   _mEvaluate.push_back(*teiter);
					//for (int i = 0; i < _episodesPerGeneration; i++)
					//  _mEvaluate.push_back(*teiter);
				}
			}
			break;
		case _VALIDATION_PHASE:
			for(teiter = _M.begin(); teiter != _M.end(); teiter++){
				if ((*teiter)->root()){
					if (useTmpNumOutcomes==false)
						numOuts = (*teiter)->numOutcomes(phase);
					else
						numOuts = (*teiter)->tmpNumOutcomes();
					for (int i = 0; i < (_validPhaseEpochs - numOuts); i++)
						_mEvaluate.push_back(*teiter);
				}
			}
			break;
		case _TEST_PHASE:
			//this happens in "satelite" agents
			if (_M.size() == 1)
				currentChampion = *(_M.begin());
			if (useTmpNumOutcomes==false)
				numOuts = currentChampion->numOutcomes(phase);
			else
				numOuts = currentChampion->tmpNumOutcomes();
			for (int i = 0; i < (_testPhaseEpochs - numOuts); i++)
				_mEvaluate.push_back(currentChampion);
			break;
		case _PLAY_PHASE:
			//this happens in "satelite" agents
			if (_M.size() == 1){
				for (int i = 0; i < playGames; i++){
					_mEvaluate.push_back(*(_M.begin()));
				}
			}
			else {
				for(teiter = _M.begin(); teiter != _M.end(); teiter++){
					if ((*teiter)->root()){
						for (int i = 0; i < playGames; i++){
							_mEvaluate.push_back(*teiter);
						}
					}
				}
			}
			break;
		default:
			;
			break;
	}
}

/********************************************************************************************
 * Assign each team a score based on multi-objective Pareto ranking with nov 
 * and performance as objectives
 */
void sbbHP::paretoRanking(long t, long level, int phase){
	vector < team * > teams;
	set < team *, teamIdComp > :: iterator teiter, teiterend;

	for(teiter = _M.begin(); teiter != _M.end(); teiter++){
		if ((*teiter)->root()){ //only consider root nodes
			teams.push_back(*teiter);
			(*teiter)->domBy(0);
			(*teiter)->domOf(0);
			(*teiter)->clearDistances();
			(*teiter)->fit((*teiter)->getMeanOutcome(_fitMode,phase,MEAN_OUT_PROP));
		}
	}

	double d0,d1;
	//measure distances w.r.t rest of population
	for(size_t i = 0; i < teams.size(); i++){
		for(size_t j = 0; j < teams.size(); j++){
			if (j > i){//not the same team and haven't considered this pair yet
				d0 = teams[i]->symbiontUtilityDistance(teams[j],_omega);
				d1 = teams[i]->ncdBehaviouralDistance(teams[j], phase);
				teams[i]->addDistance(0,d0);
				teams[i]->addDistance(1,d1);
				teams[j]->addDistance(0,d0);
				teams[j]->addDistance(1,d1);
			}
		}
	}

	/* Pareto Scoring */
	vector < team * > dominatedTeams;
	vector < team * > nonDominatedTeams;
	vector < team * > :: iterator itA;
	vector < team * > :: iterator itB;

	dominatedTeams.clear();
	nonDominatedTeams.clear();
	double novA, novB;
	for(itA = teams.begin(); itA != teams.end(); itA++){
		novA = (*itA)->nov(_distMode,_knnNov); 
		for(itB = teams.begin(); itB != teams.end(); itB++){
			novB = (*itB)->nov(_distMode,_knnNov);
			//check if itB dominates itA
			if ((((*itB)->fit()  > (*itA)->fit()  && isEqual((*itA)->fit(), (*itB)->fit(), _paretoEpsilonTeam) == false) || (novB > novA && isEqual(novA, novB, _paretoEpsilonTeam) == false)) &&
					((*itB)->fit() >= (*itA)->fit() && novB >= novA))
			{
				(*itA)->domBy((*itA)->domBy()+1);
				(*itB)->domOf((*itB)->domOf()+1);
				if(find(dominatedTeams.begin(), dominatedTeams.end(), *itA) == dominatedTeams.end())
					dominatedTeams.push_back(*itA);
			}
		}
		if ((*itA)->domBy() < 1)
			nonDominatedTeams.push_back(*itA);
	}
	for(size_t i = 0; i < teams.size(); i++){
		teams[i]->score(1-((double)teams[i]->domBy()/teams.size()));
		//teams[i]->score((double)teams[i]->domOf()/teams.size());
	}

	//Novelty reporting
	oss.str("");
	oss.precision(numeric_limits< double >::digits10+1);
	cout.precision(numeric_limits< double >::digits10+1);
	oss << std::fixed << "sbb::paretoRanking t " << t << " l " << level << " _fitMode " << _fitMode << " _distMode " << _distMode << " numFront " << nonDominatedTeams.size() << " numDom " << dominatedTeams.size() << " [id,fit,nov_0,nov_1,score] dominated ";
	for (size_t i = 0; i < dominatedTeams.size(); i++)
		oss << std::fixed << "[" << dominatedTeams[i]->id() << "," << dominatedTeams[i]->fit() << "," << dominatedTeams[i]->nov(0,_knnNov) << "," << dominatedTeams[i]->nov(1,_knnNov) << "," << dominatedTeams[i]->score() << "] ";
	oss << " nonDominated ";
	for (size_t i = 0; i < nonDominatedTeams.size(); i++)
		oss << std::fixed << "[" << nonDominatedTeams[i]->id() << "," << nonDominatedTeams[i]->fit() << "," << nonDominatedTeams[i]->nov(0,_knnNov) << "," << nonDominatedTeams[i]->nov(1,_knnNov) << "," << nonDominatedTeams[i]->score() << "] ";
	oss << endl;
	cout << oss.str();
	oss.str("");
	oss.precision(3);
	cout.precision(3);
}

/********************************************************************************************
 * Assign each team a score based on multi-objective Pareto ranking with reward 1 and 2
 * as objectives.
 */
void sbbHP::paretoRankingR1R2(long t, long level, int phase){
	vector < team * > teams;
	set < team *, teamIdComp > :: iterator teiter, teiterend;

	for(teiter = _M.begin(); teiter != _M.end(); teiter++){
		teams.push_back(*teiter);
		(*teiter)->domBy(0);
		(*teiter)->domOf(0);
		(*teiter)->clearDistances();
		(*teiter)->fit((*teiter)->getMeanOutcome(1,phase,MEAN_OUT_PROP));
	}

	double d0,d1;
	//measure distances w.r.t rest of population
	for(size_t i = 0; i < teams.size(); i++){
		for(size_t j = 0; j < teams.size(); j++){
			if (j > i){//not the same team and haven't considered this pair yet
				d0 = teams[i]->symbiontUtilityDistance(teams[j],_omega);
				d1 = teams[i]->ncdBehaviouralDistance(teams[j], phase);
				teams[i]->addDistance(0,d0);
				teams[i]->addDistance(1,d1);
				teams[j]->addDistance(0,d0);
				teams[j]->addDistance(1,d1);
			}
		}
	}

	/* Pareto Scoring */
	vector < team * > dominatedTeams;
	vector < team * > nonDominatedTeams;
	vector < team * > :: iterator itA;
	vector < team * > :: iterator itB;

	dominatedTeams.clear();
	nonDominatedTeams.clear();
	double fit2A, fit2B;
	for(itA = teams.begin(); itA != teams.end(); itA++){
		fit2A = (*itA)->getMeanOutcome(2,phase,MEAN_OUT_PROP); 
		for(itB = teams.begin(); itB != teams.end(); itB++){
			fit2B = (*itB)->getMeanOutcome(2,phase,MEAN_OUT_PROP);
			//check if itB dominates itA
			if ((((*itB)->fit()  > (*itA)->fit()  && isEqual((*itA)->fit(), (*itB)->fit(), _paretoEpsilonTeam) == false) || (fit2B > fit2A && isEqual(fit2A, fit2B, _paretoEpsilonTeam) == false)) &&
					((*itB)->fit() >= (*itA)->fit() && fit2B >= fit2A))
			{
				(*itA)->domBy((*itA)->domBy()+1);
				(*itB)->domOf((*itB)->domOf()+1);
				if(find(dominatedTeams.begin(), dominatedTeams.end(), *itA) == dominatedTeams.end())
					dominatedTeams.push_back(*itA);
			}
		}
		if ((*itA)->domBy() < 1)
			nonDominatedTeams.push_back(*itA);
	}
	for(size_t i = 0; i < teams.size(); i++){
		teams[i]->score(1-((double)teams[i]->domBy()/teams.size()));
		//teams[i]->score((double)teams[i]->domOf()/teams.size());
	}

	//Novelty reporting
	oss.str("");
	oss.precision(numeric_limits< double >::digits10+1);
	cout.precision(numeric_limits< double >::digits10+1);
	oss << std::fixed << "sbb::paretoRanking t " << t << " l " << level << " _fitMode " << _fitMode << " _distMode " << _distMode << " numFront " << nonDominatedTeams.size() << " numDom " << dominatedTeams.size() << " [id,fit,nov_0,nov_1,score] dominated ";
	for (size_t i = 0; i < dominatedTeams.size(); i++)
		oss << std::fixed << "[" << dominatedTeams[i]->id() << "," << dominatedTeams[i]->fit() << "," << dominatedTeams[i]->nov(0,_knnNov) << "," << dominatedTeams[i]->nov(1,_knnNov) << "," << dominatedTeams[i]->score() << "] ";
	oss << " nonDominated ";
	for (size_t i = 0; i < nonDominatedTeams.size(); i++)
		oss << std::fixed << "[" << nonDominatedTeams[i]->id() << "," << nonDominatedTeams[i]->fit() << "," << nonDominatedTeams[i]->nov(0,_knnNov) << "," << nonDominatedTeams[i]->nov(1,_knnNov) << "," << nonDominatedTeams[i]->score() << "] ";
	oss << endl;
	cout << oss.str();
	oss.str("");
	oss.precision(3);
	cout.precision(3);
}
/**********************************************************************************************************/
void sbbHP::printEvaluationVector(long t){
	vector < team * > :: iterator teiter;
	cout << "printEvaluationVector t " << t << "-----------------------------------------" << endl;
	for(teiter = _mEvaluate.begin(); teiter != _mEvaluate.end(); teiter++)
		cout << (*teiter)->id() << endl;
}
/**********************************************************************************************************/
void sbbHP::printHostGraphs(long level){
	char outputFilename[80];
	ofstream ofs;
	sprintf(outputFilename, "%s","Nodes");
	if (fileExists(outputFilename)){
		char tmp[80];
		sprintf(tmp,"%s.%d.backup",outputFilename,(int)time(NULL));
		rename(outputFilename,tmp);
	}
	ofs.open(outputFilename, ios::out);
	if (!ofs)
		die(__FILE__, __FUNCTION__, __LINE__, "Can't open file.");

	set < learner *> :: iterator leiter, leiterEnd;
	set < team *, teamIdComp > :: iterator teiter, teiterend;

	ofs << "id,type" << endl;
	for (int i = 0; i < numAtomicActions(); i++)
		ofs << "a" << -1-i << ",atomic" << endl;
	for(leiter = _L.begin(), leiterEnd = _L.end(); leiter != leiterEnd; leiter++)
		ofs << "s" << (*leiter)->id() << ",symbiont" << endl;
	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
		ofs << "h" << (*teiter)->id() << ",host" << endl;
	//ofs << "Nodes end" << endl;
	ofs.close();

	sprintf(outputFilename, "%s","Links");
	if (fileExists(outputFilename)){
		char tmp[80];
		sprintf(tmp,"%s.%d.backup",outputFilename,(int)time(NULL));
		rename(outputFilename,tmp);
	}
	ofs.open(outputFilename, ios::out);
	if (!ofs)
		die(__FILE__, __FUNCTION__, __LINE__, "Can't open file.");

	//cout << "Links start" << endl;
	ofs << "from,to" << endl;
	for(leiter = _L.begin(), leiterEnd = _L.end(); leiter != leiterEnd; leiter++){
		ofs << "s" << (*leiter)->id() << ",";
		if ((*leiter)->action() < 0) ofs << "a";
		else ofs << "h";
		ofs << (*leiter)->action() << endl;
	}
	for(teiter = _M.begin(); teiter != _M.end(); teiter++){
		set < learner * > mem;
		(*teiter)->members(&mem);
		set < learner * > :: iterator leiter;
		for(leiter = mem.begin(); leiter != mem.end(); leiter++){
			ofs << "h" << (*teiter)->id() << ",s" << (*leiter)->id() << endl;
		}
	}
	ofs.close();
	//cout << "Links end" << endl;
}

/**********************************************************************************************************/
void sbbHP::printHostGraphsDFS(long level, long t){

	char outputFilename[80];
	ofstream ofs;


	set < learner *> :: iterator leiterRoot;
	set < team *, teamIdComp > :: iterator teiter, teiterRoot;

	set <learner*> learners;
	set <team*> teams;

	for(teiter = _M.begin(); teiter != _M.end(); teiter++){
		if ((*teiter)->root()){
			learners.clear();
			teams.clear();
			(*teiter)->getAllNodes(_teamMap, teams, learners);

			//Save Nodes
			sprintf(outputFilename, "hostGraphs/%s%d%s%d","Nodes-t",(int)t,"-host",(int)(*teiter)->id());
			ofs.open(outputFilename, ios::out);
			if (!ofs)
				die(__FILE__, __FUNCTION__, __LINE__, "Can't open file.");
			ofs << "id,type" << endl;
			for(leiterRoot = learners.begin(); leiterRoot != learners.end(); leiterRoot++){
				ofs << "s" << (*leiterRoot)->id() << ",symbiont" << endl;
				if ((*leiterRoot)->action() < 0)
					ofs << "a" << (*leiterRoot)->id() <<",atomic" << (*leiterRoot)->action() << endl;
			}
			for(teiterRoot = teams.begin(); teiterRoot != teams.end(); teiterRoot++)
				ofs << "h" << (*teiterRoot)->id() << ",host" << endl;
			ofs.close();

			//Save Links
			sprintf(outputFilename, "hostGraphs/%s%d%s%d","Links-t",(int)t,"-host",(int)(*teiter)->id());
			ofs.open(outputFilename, ios::out);
			if (!ofs)
				die(__FILE__, __FUNCTION__, __LINE__, "Can't open file.");
			ofs << "from,to" << endl;
			for(leiterRoot = learners.begin(); leiterRoot != learners.end(); leiterRoot++){
				ofs << "s" << (*leiterRoot)->id() << ",";
				if ((*leiterRoot)->action() < 0) ofs << "a" << (*leiterRoot)->id() << endl;
				else ofs << "h" << (*leiterRoot)->action() << endl;
			}
			for(teiterRoot = teams.begin(); teiterRoot != teams.end(); teiterRoot++){
				set < learner * > mem;
				(*teiterRoot)->members(&mem);
				set < learner * > :: iterator leiter;
				for(leiter = mem.begin(); leiter != mem.end(); leiter++)
					ofs << "h" << (*teiterRoot)->id() << ",s" << (*leiter)->id() << endl;
			}
			ofs.close();
		}
	}
}

/**********************************************************************************************************/
void sbbHP::printLearnerInfo(long t, long level){
	set < learner *> :: iterator leiter, leiterEnd;
	oss.str("");
	oss << "printLearnerInfo start" << endl;
	for(leiter = _L.begin(), leiterEnd = _L.end(); leiter != leiterEnd; leiter++)
		oss << (*leiter)->checkpoint() << endl;
	oss << "printLearnerInfo end" << endl;
	cout << oss.str();
	oss.str("");
}
/**********************************************************************************************************/
void sbbHP::printPointInfo(long t, long level, int phase){
	set < point * > :: iterator poiter;
	oss.str("");
	for(poiter = _P.begin(); poiter != _P.end(); poiter++){
		oss << "ptinfo t " << t << " lev " << level  << " mPhase " << phase << " id " << (*poiter)->id() << " gtime " << (*poiter)->gtime() << " phase " << (*poiter)->phase();
		oss << " key " << (*poiter)->key();
		oss << " marked " << ((*poiter)->marked() ? 1 : 0);
		oss << " slice " << (*poiter)->slice();
		oss << " solved " << ((*poiter)->solved() ? 1 : 0);
		oss << " dimP " << (*poiter)->dimPoint();
		vector <double> pState;
		(*poiter)->pointState(pState);
		oss << " pState " << vecToStr(pState);
		oss << " dimB " << (*poiter)->dimBehavioural();
		vector <double> bState;
		(*poiter)->behaviouralState(bState);
		oss << " bState " << vecToStr(bState);
		oss << " auxDoubles " << (*poiter)->auxDouble(0) << " " << (*poiter)->auxDouble(1) << " " << (*poiter)->auxDouble(2);
		oss << endl;
	}
	cout << oss.str();
	oss.str("");
}
/**********************************************************************************************************/
void sbbHP::printTeamInfo(long t, long level, int phase){
	set < team *, teamIdComp > :: iterator teiter, teiterend;
	ostringstream tmposs;
	map < point *, double, pointLexicalLessThan > allOutcomes;
	map < point *, double > :: iterator myoiter;
	vector <int> behaviourSequence;
	oss.str("");
	for(teiter = _M.begin(); teiter != _M.end(); teiter++){
		//cout << (*teiter)->toString("PTEAM") << endl;
		tmposs << "teamsToString t " << t << " runningLevel " << level << " ";
		oss << "-------------------------------------------------------------------" << endl;
		set <team*> visitedTeams;
		oss << (*teiter)->toString(tmposs.str(), _teamMap, visitedTeams);
		tmposs.str("");
		oss << *(*teiter) << endl;
		oss << "tminfo t " << t << " lev " << level << " id " << (*teiter)->id() << " gtime " << (*teiter)->gtime();
		oss << " root " << ((*teiter)->root() ? 1 : 0);
		oss << " size " << (*teiter)->size();
		oss << " asize " << (*teiter)->asize();
		oss << " age " << t - (*teiter)->gtime() << " numOut " << (*teiter)->numOutcomes(phase);
		oss << " meanReward_0 " << (*teiter)->getMeanOutcome(0,phase,MEAN_OUT_PROP);
		oss << " meanReward_1 " << (*teiter)->getMeanOutcome(1,phase,MEAN_OUT_PROP);
		oss << " meanReward_2 " << (*teiter)->getMeanOutcome(2,phase,MEAN_OUT_PROP);
		oss << " fit " << (*teiter)->fit();
		oss << " nov_0 " << (*teiter)->nov(0,_knnNov);
		oss << " nov_1 " << (*teiter)->nov(1,_knnNov);
		oss << " score " << (*teiter)->score();
		visitedTeams.clear();
		oss << " ePolicyInstructions " << (*teiter)->policyInstructions(_teamMap, visitedTeams, true);
		visitedTeams.clear();
		oss << " policyInstructions " << (*teiter)->policyInstructions(_teamMap, visitedTeams, false);
		set <learner*> learners;
		visitedTeams.clear();
		(*teiter)->getAllNodes(_teamMap, visitedTeams, learners);
		oss << " symCount " << learners.size();
		oss << " hostCount " << visitedTeams.size();
		oss << " members ";
		set < learner * > mem;
		(*teiter)->members(&mem);
		set < learner * > :: iterator leiter;
		for(leiter = mem.begin(); leiter != mem.end(); leiter++)
			oss << " |" << (*leiter)->id() << ":" << (*leiter)->action() << "|";
		oss << " amembers ";
		mem.clear();
		(*teiter)->activeMembers(&mem);
		for(leiter = mem.begin(); leiter != mem.end(); leiter++)
			oss << " |" << (*leiter)->id() << ":" << (*leiter)->action() << ":" << (*leiter)->refs() << "|";

		oss << " childUp ";
		if ((*teiter)->score() > (*teiter)->parentScore())
			oss << "1";
		else
			oss << "0";
		vector <long> ancestors;
		(*teiter)->getAllAncestors(ancestors);
		oss << " ancestors" << vecToStr(ancestors);
		(*teiter)->outcomes(allOutcomes,phase);
		oss << " allOutcomes";
		for(myoiter = allOutcomes.begin(); myoiter != allOutcomes.end(); myoiter++)
			oss << " [" << (myoiter->second) << ":" << (myoiter->first)->auxDouble(1) << "," << (myoiter->first)->auxDouble(2) << "," << (myoiter->first)->auxDouble(3) << "]";
		oss << " behaviourProfile ";
		behaviourSequence.clear();
		(*teiter)->getBehaviourSequence(behaviourSequence,phase);
		oss << vecToStrNoSpace(behaviourSequence);
		//oss << endl;
		visitedTeams.clear();
		set < long > features;
		(*teiter)->policyFeatures(_teamMap, visitedTeams, features);
		oss << "policyFeatures uniq " << features.size() << " feat ";
		set <long >::iterator feiter;
		for(feiter = features.begin(); feiter!=features.end();feiter++)
			oss << " " << (*feiter); 
		oss << endl;
	}
	oss << "-------------------------------------------------------------------" << endl;
	cout << oss.str();
	oss.str("");
}

/***********************************************************************************************************/
void sbbHP::processEvalResults(int t, int level, int phase, int keeper){
	set < team *, teamIdComp > :: iterator teiter, teiterEnd;
	vector < double > testOuts;
	ifstream inFile;
	char inputFilename[80];

	//point state is not stored, so use a blank
	vector <double> blankPState;
	for (int i = 0; i < _dimP; i++) blankPState.push_back(0);

	oss.str("");
	oss << "evals/eval." << phase << "." << keeper << "." << _seed << ".rslt";
	sprintf( inputFilename, "%s", oss.str().c_str());

	oss.str("");
	oss << "Can't open eval file read: " << inputFilename;
	inFile.open(inputFilename, ios::in);
	if (!inFile) {
		die(__FILE__, __FUNCTION__, __LINE__, oss.str().c_str());
	}
	oss.str("");

	string oneline;
	char delim = ':';
	int id;
	//	double somedouble_1;
	//	double somedouble_2;
	//	double somedouble_3;
	vector <double> rewards;
	vector < string > outcomeFields;
	vector < string > activeMemberIdsString;
	vector < long > activeMemberIds;
	vector < double > state;
	vector < string > stateString;
	oss.str();

	while (getline(inFile, oneline)){
		outcomeFields.clear();
		activeMemberIdsString.clear();
		activeMemberIds.clear();
		state.clear();
		stateString.clear();

		split(oneline,delim,outcomeFields);

		id = atoi(outcomeFields[0].c_str());

		split(outcomeFields[1],' ',activeMemberIdsString);
		for (size_t i = 0; i < activeMemberIdsString.size(); i++)
			activeMemberIds.push_back(atoi(activeMemberIdsString[i].c_str()));

		rewards.push_back(atof(outcomeFields[2].c_str()));
		rewards.push_back(atof(outcomeFields[3].c_str()));
		rewards.push_back(atof(outcomeFields[4].c_str()));

		if (outcomeFields.size() > 5){
			split(outcomeFields[5],' ',stateString);
			for (size_t i = 0; i < stateString.size(); i++)
				state.push_back(atof(stateString[i].c_str()));
		}

		if (phase == _TRAIN_PHASE)//this only makes sense for keepaway
			_simTime += rewards[0];

		if (phase != _TEST_PHASE){
			for(teiter = _M.begin(); teiter != _M.end(); teiter++){
				if ((*teiter)->id() == id){
					(*teiter)->updateActiveMembersFromIds(activeMemberIds);
					//(*teiter)->setOutcome(new point(t,phase,point_count++, _dimP, &blankPState[0], _dimB, &state[0], &rewards[0]),rewards[_fitMode],_numStoredOutcomesPerHost[phase]);
					(*teiter)->setOutcome(new point(t,phase,point_count++, state, rewards),rewards[_fitMode],_numStoredOutcomesPerHost[phase]);
				}
			}
		}
		else{
			if (currentChampion->id() != id){
				oss.str("");
				oss << "test error: currentChampion->id() != id: " << currentChampion->id() << " != " << id;
				die(__FILE__, __FUNCTION__, __LINE__, oss.str().c_str());

			}
			//currentChampion->setOutcome(new point(point_count, state.size(), t, &state[0], point_count++, &rewards[0],phase),rewards[_fitMode],_numStoredOutcomesPerHost[phase]);
			//currentChampion->setOutcome(new point(t,phase,point_count++, _dimP, &blankPState[0], _dimB, &state[0], &rewards[0]),rewards[_fitMode],_numStoredOutcomesPerHost[phase]);
			currentChampion->setOutcome(new point(t,phase,point_count++, state, rewards),rewards[_fitMode],_numStoredOutcomesPerHost[phase]);
		}
	}
	inFile.close();

	if (phase == _TEST_PHASE){
		map < point *, double > :: iterator myoiter;
		map < point *, double, pointLexicalLessThan > myOutcomes;
		currentChampion->outcomes(myOutcomes,phase);
		oss.str("");
		oss << "soc::test t " << t << " l " << currentChampion->level();
		oss << " simTime " << _simTime;
		oss << " meanOutcomeTest " << currentChampion->getMeanOutcome(_TEST_REWARD,_TEST_PHASE,1.0);
		oss << " numOutcomesTest " << currentChampion->numOutcomes(_TEST_PHASE);
		oss << " allOutcomesTest";
		for(myoiter = myOutcomes.begin(); myoiter != myOutcomes.end(); myoiter++)
			if(myoiter->first->phase() == _TEST_PHASE)
				oss << " " << myoiter->first->auxDouble(_TEST_REWARD);
		cout << oss.str() << endl;
		oss.str("");
	}
}

/********************************************************************************************/
void sbbHP::pruneLearners(bool checkOmega) /* If true, prune only if the team size equals _omega. */
{
	set < team *, teamIdComp > :: iterator teiter;

	set < learner * > members, active;
	set < learner * > setdiff;
	set < learner * > :: iterator leiter;

	/* Remove inactive team members from the teams. */

	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
	{
#ifdef MYDEBUG
		cout << "sbbHP::pruneLearners check " << checkOmega << " size " << (*teiter)->size();
#endif

		if((checkOmega == false) || ((*teiter)->size() == _omega))
		{
			members.clear();
			active.clear();
			setdiff.clear();

			(*teiter)->members(&members); /* Get all members. */
			(*teiter)->activeMembers(&active); /* Get active members. */

			/* Inactive members are members \ active. */

			set_difference(members.begin(), members.end(),
					active.begin(), active.end(),
					insert_iterator < set < learner * > > (setdiff, setdiff.begin()));

#ifdef MYDEBUG
			cout << " members";
			for(leiter = members.begin(); leiter != members.end(); leiter++)
				cout << " " << (*leiter)->id();

			cout << " active";
			for(leiter = active.begin(); leiter != active.end(); leiter++)
				cout << " " << (*leiter)->id();

			cout << " inactive";
			for(leiter = setdiff.begin(); leiter != setdiff.end(); leiter++)
				cout << " " << (*leiter)->id();
#endif

			for(leiter = setdiff.begin(); leiter != setdiff.end() && (*teiter)->size() > 2; leiter++)
			{
				(*leiter)->refDec();
				(*teiter)->removeLearner(*leiter);
			}
		}

#ifdef MYDEBUG
		cout << " finalsize " << (*teiter)->size() << endl;
#endif
	}
}

/***********************************************************************************************************
 * Read in populations from a checkpoint file. (This whole process needs a rewrite sometime.)
 **********************************************************************************************************/
//long sbbHP::readCheckpoint(int t, int level,int id,int phase,bool file, istream& is){
void sbbHP::readCheckpoint(int phase, istream& is){
	std::pair<std::set<team *, teamIdComp>::iterator,bool> ret;

	set < learner * > testTeamMembers;

	set < team *, teamIdComp > :: iterator teiter, teiterEnd;
	set < learner * > :: iterator leiter, leiterEnd;

	string oneline;
	char delim=':';
	char *token;
	long memberId = 0;
	long max_team_count = -1;
	long max_learner_count = -1;

	vector < string > outcomeFields;

	while (getline(is, oneline)){
		outcomeFields.clear();

		split(oneline,delim,outcomeFields);

		if (outcomeFields[0].compare("seed") == 0){
			_seed = atol(outcomeFields[1].c_str());
		}

		else if (outcomeFields[0].compare("learner") == 0){
			long id = 0;
			long gtime = 0;
			long action = 0;;
			long dim = 0;
			int nrefs = 0;
			vector < instruction * > bid;
			instruction *in;
			id = atol(outcomeFields[1].c_str());
			if (id > max_learner_count) max_learner_count = id;
			gtime = atol(outcomeFields[2].c_str());
			action = atol(outcomeFields[3].c_str());
			dim = atol(outcomeFields[4].c_str());
			if (phase < _TEST_PHASE) nrefs = atol(outcomeFields[5].c_str());
			else nrefs = 0;

			for (size_t ii = 6; ii < outcomeFields.size(); ii++){
				token = (char*)outcomeFields[ii].c_str();
				in = new instruction();
				in->reset();
				for (int j = 22, k = 0; j >= 0; j--, k++){ //there are 23 bits in each instruction
					if (token[j] == '1'){
						in->flip(k);
					}
				}
				bid.push_back(in);
			}
			learner *l;
			l = new learner(gtime, gtime, action, dim, id, nrefs, bid);
			_L.insert(l);
		}


		else if (outcomeFields[0].compare("team") == 0){
			long id = 0;
			long gtime = 0;
			long level = 0;
			long numOutcomes = 0;
			set < learner * > members;
			team *m;
			id = atol(outcomeFields[1].c_str());
			if (id > max_team_count) max_team_count = id;
			gtime = atol(outcomeFields[2].c_str());
			level = atol(outcomeFields[3].c_str());
			numOutcomes = atol(outcomeFields[4].c_str());

			m = new team(level, gtime, id);
			m->tmpNumOutcomes(numOutcomes);
			for (size_t ii = 5; ii < outcomeFields.size(); ii++){
				memberId = atol(outcomeFields[ii].c_str());
				for(leiter = _L.begin(), leiterEnd = _L.end(); leiter != leiterEnd; leiter++){
					if ((*leiter)->id() == memberId){
						m->addLearner(*leiter);
					}
				}

			}
			ret = _M.insert(m);

			//if we get a duplicate team id, scale by 100 until unique
			while (ret.second==false){
				m->id(m->id()*100);
				ret = _M.insert(m);
			}
		}
	}

	/* In _TEST_PHASE all learner nrefs will be set to zero, so we recalculate them here based on
	 * the single test team.
	 */
	if (phase == _TEST_PHASE || phase == _PLAY_PHASE){
		teiter = _M.begin();
		(*teiter)->members(&testTeamMembers);
		for(leiter = testTeamMembers.begin(); leiter != testTeamMembers.end(); leiter++)
			(*leiter)->refInc();
	}

	learner_count = max_learner_count+1;
	team_count = max_team_count+1;

	setRoots();
}

/*********************************************************************************************************/
void sbbHP::recalculateLearnerRefs(){

	set < learner * > :: iterator leiter, leiterEnd;
	for(leiter = _L.begin(); leiter != _L.end(); leiter++)
		(*leiter)->setNrefs(0);

	set < team * > :: iterator teiter, teiterEnd;
	set < learner * > mem;
	for(teiter = _M.begin(); teiter != _M.end(); teiter++){
		(*teiter)->members(&mem);
		set < learner * > :: iterator leiter;
		for(leiter = mem.begin(); leiter != mem.end(); leiter++)
			(*leiter)->refInc(); 
		mem.clear();
	}
}

/*********************************************************************************************************/
void sbbHP::scaleTeamAndLearnerIds(long i){

	set < learner * > :: iterator leiter, leiterEnd;
	for(leiter = _L.begin(); leiter != _L.end(); leiter++)
		(*leiter)->id((*leiter)->id()+i);
	set < team * > :: iterator teiter, teiterEnd;
	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
		(*teiter)->id((*teiter)->id()+i);
}
/***********************************************************************************************************/
void sbbHP::selPoints(long t)
{
        //set < point * > :: iterator poiter;

	//for(poiter = _P.begin(); poiter != _P.end(); poiter++)
	//	(*poiter)->mark();

		/* Shared score. */
		map < point *, double > score;
		map < point *, double > :: iterator sciter;
	
		set < point * > :: iterator poiter;
	
		vector < point * > pointvec;
	
		map < point *, double > :: iterator miter;
	
		double sc;
		double mean;
		int count;
		double out;
		vector < double > outcomes;
		set < team * > :: iterator teiter;
	
		vector < double > state;
	
        #ifdef MYDEBUG
		cout << "sbbHP::selPoints _Psize " << _P.size() << " _Msize " << _M.size() << endl;
	#endif
        	for(poiter = _P.begin(); poiter != _P.end(); poiter++)
		{
			outcomes.clear();
			mean = 0;
			count = 0;
	
	#ifdef MYDEBUG
			cout << "sbbHP::selPoints " << t << " pt " << (*poiter)->id() << " out";
	#endif
	
			for(teiter = _M.begin(); teiter != _M.end(); teiter++)
			{
				if((*teiter)->getOutcome(*poiter, &out) == false)
					die(__FILE__, __FUNCTION__, __LINE__, "outcome not found");
	
	#ifdef MYDEBUG
				cout << " " << out;
	#endif
				mean += out;
				outcomes.push_back(out);
			}
	
			/* Multiply by 0.999999 just in case all 1s, otherwise count would be 0. */
	
			mean = 0.999999 * mean / outcomes.size();
	
			if(mean > NEARZERO)
			{
				for(size_t i = 0; i < outcomes.size(); i++)
					if(outcomes[i] > mean)
						count++;
			} /* Else count = 0. */
	
	#ifdef MYDEBUG
			cout << " mean " << mean << " count " << count;
	#endif
	
			if(count == 0)
				sc = 0;
			else
				sc = (double) (1 + outcomes.size() - count) / outcomes.size();
	
	#ifdef MYDEBUG
			cout << " score " << sc << endl;
	#endif
	
			score.insert(map < point *, double > :: value_type(*poiter, sc));
		}
	
		/* Store all the points in a vector. */
	
		pointvec.insert(pointvec.begin(), _P.begin(), _P.end());
	
	#ifdef MYDEBUG
		for(size_t i = 0; i < pointvec.size(); i++)
		{
			pointvec[i]->pointState(state);
			cout << "sbbHP::selPoints " << t << " " << i << " point " << pointvec[i]->id();
			cout << " gtime " << pointvec[i]->gtime() << " state" << vecToStr(state) << endl;
		}
	#endif
	
		for(size_t i = 0; i < pointvec.size(); i++)
		{
			/* Get score and set key for sorting. */
	
			if((sciter = score.find(pointvec[i])) == score.end())
				die(__FILE__, __FUNCTION__, __LINE__, "cannot find score");
	
			pointvec[i]->key((double) sciter->second);
			pointvec[i]->slice(pointvec[i]->key());
	
	#ifdef MYDEBUG
			cout << "sbbHP::selPoints " << _seed << " t " << t << " " << pointvec[i]->id();
			cout << " raw " << sciter->second  << " key " << pointvec[i]->key() << endl;
	#endif
		}
	
		partial_sort(pointvec.begin(), pointvec.begin() + _Pgap, pointvec.end(), lessThan < point > ());
	
	#ifdef MYDEBUG
		for(size_t i = 0; i < pointvec.size(); i++)
			cout << "sbbHP::selPoints " << t << " point " << pointvec[i]->id() << " key " << pointvec[i]->key() << endl;
	#endif
	
		/* Mark the worst points for deletion. */
	
		for(size_t i = 0; i < _Pgap; i++)
		{
			if(pointvec[i]->gtime() != t) _pdom++;
	
			pointvec[i]->mark();
	
	#ifdef MYDEBUG
			cout << "sbbHP::selPoints " << t << " removing " << pointvec[i]->id() << endl;
	#endif
		}
}
/********************************************************************************************/
void sbbHP::selTeams(long t, long level)
{
	vector < team * > teams;
	set < team *, teamIdComp > :: iterator teiter, teiterend;

	if(_diversityMode == 0){
		//this diversityMode runs in here for reporting
		//paretoRanking(t, level);
		//reset scores to fit only
		diversityMode0(t, level);
	}
	else if (_diversityMode == 7)
		paretoRanking(t, level);
	else if (_diversityMode == 8)
		paretoRankingR1R2(t, level);

	ostringstream tmposs;
	map < point *, double, pointLexicalLessThan > allOutcomes;
	map < point *, double > :: iterator myoiter;

	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
		if((*teiter)->root())
			teams.push_back(*teiter);

	// Select the top teams.
	for(size_t i = 0; i < teams.size(); i++)
		teams[i]->key(teams[i]->score());
	// Sort the teams by their keys.
	partial_sort(teams.begin(), teams.begin() + floor(teams.size()/2), teams.end(), lessThan < team > ());//__Mgap becomes half of all root nodes
#ifdef MYDEBUG
	for(int i = 0; i < teams.size(); i++)
		cout << "_id " << _id << "selTeams " << t << " sorted " << teams[i]->id() << " key " << teams[i]->key() << endl;
#endif
	// At this point, the order of teams no longer matches the order of the other vectors.
	int numOldDeleted = 0;
	int numDeleted = 0;
	oss << "sbb::selTeams deletedAge";
	for(int i = 0; i < floor(teams.size()/2); i++){
		oss << " " << t - teams[i]->gtime();
		if(teams[i]->gtime() != t){
			numOldDeleted++;
			_mdom++; // The team is old.
		}
#ifdef MYDEBUG
		cout << "sbb::selTeams deleting " << teams[i]->id() << endl;
#endif
		_M.erase(teams[i]);
		delete teams[i]; // Learner refs deleted automatically.
		numDeleted++;
	}

	oss << " numDeleted " << numDeleted << " numOldDeleted " << numOldDeleted << " keptAge";
	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
		oss << " " << t - (*teiter)->gtime();
	oss << " keptIds";
	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
		oss << " " << (*teiter)->id();
	oss << endl;
	cout << oss.str();
	oss.str("");
}

/********************************************************************************************/
void sbbHP::setParams(){
	oss.str("");
	oss << "sbb." << _seed << ".arg";

	map < string, string > args;

	readMap(oss.str(), args);

	oss.str("");
	oss << "sbbHP parameters:" << endl;

	map < string, string > :: iterator maiter;

	/* Get arguments. */

	if((maiter = args.find("paretoEpsilonTeam")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg paretoEpsilonTeam");

	_paretoEpsilonTeam = stringTodouble(maiter->second);

	if((maiter = args.find("teamPow")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg teamPow");

	_teamPow = stringToLong(maiter->second);

	if((maiter = args.find("splitLevel")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg splitLevel");

	int sl = stringToInt(maiter->second);
	if (sl > 0)
		_splitLevel = true;
	else
		_splitLevel = false;

	if((maiter = args.find("Msize")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg Msize");

	_Msize = stringToInt(maiter->second);

	if((maiter = args.find("pAtomic")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pAtomic");

	_pAtomic = stringTodouble(maiter->second);

	if((maiter = args.find("Pgap")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg Pgap");

	_Pgap = stringToInt(maiter->second);

	if((maiter = args.find("pmd")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pmd");

	_pmd = stringTodouble(maiter->second);

	if((maiter = args.find("pma")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pma");

	_pma = stringTodouble(maiter->second);

	if((maiter = args.find("pmm")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pmm");

	_pmm = stringTodouble(maiter->second);

	if((maiter = args.find("pmn")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pmn");

	_pmn = stringTodouble(maiter->second);

	if((maiter = args.find("Psize")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg Psize");

	_Psize = stringToInt(maiter->second);

	if((maiter = args.find("omega")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg omega");

	_omega = stringToInt(maiter->second);

	if((maiter = args.find("t")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg t");

	_t = stringToLong(maiter->second);

	if((maiter = args.find("numLevels")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg numLevels");

	_numLevels = stringToInt(maiter->second);

	if((maiter = args.find("Mgap")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg Mgap");

	_Mgap = stringToInt(maiter->second);

	if((maiter = args.find("maxProgSize")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg maxProgSize");

	_maxProgSize = stringToInt(maiter->second);

	if((maiter = args.find("pBidMutate")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pBidMutate");

	_pBidMutate = stringTodouble(maiter->second);

	if((maiter = args.find("pBidSwap")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pBidSwap");

	_pBidSwap = stringTodouble(maiter->second);

	if((maiter = args.find("pBidDelete")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pBidDelete");

	_pBidDelete = stringTodouble(maiter->second);

	if((maiter = args.find("pBidAdd")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pBidAdd");

	_pBidAdd = stringTodouble(maiter->second);

	if((maiter = args.find("diversityMode")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg diversityMode");

	_diversityMode = stringToInt(maiter->second);

	if((maiter = args.find("stateDiscretizationSteps")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg stateDiscretizationSteps");

	_stateDiscretizationSteps = stringToInt(maiter->second);

	if((maiter = args.find("sigmaShare")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg sigmaShare");

	_sigmaShare = stringTodouble(maiter->second);

	if((maiter = args.find("pNoveltyGeno")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pNoveltyGeno");

	_pNoveltyGeno = stringTodouble(maiter->second);

	if((maiter = args.find("pNoveltyPheno")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg pNoveltyPheno");

	_pNoveltyPheno = stringTodouble(maiter->second);

	if((maiter = args.find("knnNovelty")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg knnNovelty");

	_knnNov = stringToInt(maiter->second);

	if((maiter = args.find("validPhaseEpochs")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg validPhaseEpochs");

	_validPhaseEpochs = stringToLong(maiter->second);

	if((maiter = args.find("testPhaseEpochs")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg testPhaseEpochs");

	_testPhaseEpochs = stringToLong(maiter->second);

	if((maiter = args.find("episodesPerGeneration")) == args.end())
		die(__FILE__, __FUNCTION__, __LINE__, "cannot find arg episodesPerGeneration");

	_episodesPerGeneration = stringToLong(maiter->second);

	oss << "seed " << _seed << endl;

	oss << "paretoEpsilonTeam " << _paretoEpsilonTeam << endl;

	oss << "teamPow " << _teamPow << endl;

	oss << "Msize " << _Msize << endl;
	oss << "pAtomic " << _pAtomic << endl;
	oss << "pmd " << _pmd << endl;
	oss << "pma " << _pma << endl;
	oss << "pmm " << _pmm << endl;
	oss << "pmn " << _pmn << endl;
	oss << "omega " << _omega << endl;
	oss << "t " << _t << endl;
	oss << "numLevels " << _numLevels << endl;
	oss << "Mgap " << _Mgap << endl;

	oss << "maxProgSize " << _maxProgSize << endl;
	oss << "pBidMutate " << _pBidMutate << endl;
	oss << "pBidSwap " << _pBidSwap << endl;
	oss << "pBidDelete " << _pBidDelete << endl;
	oss << "pBidAdd " << _pBidAdd << endl;

	oss << "diversityMode " << _diversityMode << endl;
	oss << "stateDiscretizationSteps " << _stateDiscretizationSteps << endl;
	oss << "pNoveltyGeno " << _pNoveltyGeno << endl;
	oss << "pNoveltyPheno " << _pNoveltyPheno << endl;

	oss << "validPhaseEpochs " << _validPhaseEpochs << endl;
	oss << "testPhaseEpochs " << _testPhaseEpochs << endl;
	oss << "episodesPerGeneration " << _episodesPerGeneration << endl;

	cout << oss.str() << endl;
	oss.str("");

	if(_numLevels < 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg numLevels < 1");

	if(_Msize < 2)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg Msize < 2");

	if(_pmd < 0 || _pmd > 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg pmd < 0 || pmd > 1");

	if(_pma < 0 || _pma > 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg pma < 0 || pma > 1");

	if(_pmm < 0 || _pmm > 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg pmm < 0 || pmm > 1");

	if(_pmn < 0 || _pmn > 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg pmn < 0 || pmn > 1");

	if(_omega < 2)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg omega < 2");

	if(_t < 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg t < 1");

	if(_Mgap < 1 || _Mgap >= _Msize)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg Mgap < 1 || Mgap >= Msize");

	if(_maxProgSize < 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg _maxProgSize < 1");

	if(_pBidDelete < 0 || _pBidDelete > 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg pBidDelete < 0 || pBidDelete > 1");

	if(_pBidAdd < 0 || _pBidAdd > 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg pBidAdd < 0 || pBidAdd > 1");

	if(_pBidSwap < 0 || _pBidSwap > 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg pBidSwap < 0 || pBidSwap > 1");

	if(_pBidMutate < 0 || _pBidMutate > 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg pBidMutate < 0 || pBidMutate > 1");

	if(_paretoEpsilonTeam < 0)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg _paretoEpsilonTeam < 0");

	if(_teamPow < 1)
		die(__FILE__, __FUNCTION__, __LINE__, "bad arg teamPow < 1");

	/* Bidding behaviour. */
	for(int i = 0; i < PROFILE_SIZE_INI; i++){
		_profilePoints.push_back(initUniformPointGeneric(-3, point_count++, _VALIDATION_PHASE));
		_profilePointsFIFO.push_back(initUniformPointGeneric(-3, point_count++, _VALIDATION_PHASE));
	}
}

/*********************************************************************************************************/
int sbbHP::setRoots(){

	_teamMap.clear();
	set < team * , teamIdComp > :: iterator teiter;

	for(teiter = _M.begin(); teiter != _M.end(); teiter++){
		(*teiter)->root(true);
		_teamMap[(*teiter)->id()]=*teiter;
	}
	int nroots = 0;
	set < learner * > :: iterator leiter;
	for(leiter = _L.begin(); leiter != _L.end(); leiter++)
		if ((*leiter)->action() >= 0){
			_teamMap[(*leiter)->action()]->root(false);
			nroots++;
		}
	return nroots;
}

/*********************************************************************************************************/
void sbbHP::splitLevelPrep(){
	set < learner * > :: iterator leiter, leiterEnd;
	for(leiter = _L.begin(); leiter != _L.end(); leiter++)
		(*leiter)->action((*leiter)->action()+1);
}

/********************************************************************************************/
void sbbHP::stats(long t,
		long level)
{
	int numRoots = setRoots();
	oss.str("");
	int sumTeamSizes = 0;
	vector <int> allNumOutcomes;

	/* Quartiles for team sizes. */
	vector < int > msize;
	int mq1 = (int) (numRoots * 0.25);
	int mq2 = (int) (numRoots * 0.5);
	int mq3 = (int) (numRoots * 0.75);

	/* Team node counts. */
	vector < int > mnode;

	/* Learner node Counts. */
	vector < int > lnode;

	set < team *, teamIdComp > :: iterator teiter;

	/* Mean outcome for a team. */
	double meanOutcome[3];

	double meanChildUp = 0;

	double maxMeanOutcome[3]={0,0,0};
	double meanMeanOutcome[3]={0,0,0};
	double minMeanOutcome[3]={HUGE_VAL,HUGE_VAL,HUGE_VAL};
	int numOutcomesForMaxMean[3];
	int numOutcomesForMinMean[3];
	int maxMeanSize[3];
	int minMeanSize[3];
	long maxMeanGtime[3];
	long minMeanGtime[3];

	long gtime = 0;

	long minGtime = HUGE_VAL;
	double meanAge = 0;

	vector < double > state;

	set < team *, teamIdComp > :: iterator teiter1, teiter2;

	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
	{
		if((*teiter)->root()){
			msize.push_back((*teiter)->size());
			set <team*> teams;
			set <learner*> learners;
			(*teiter)->getAllNodes(_teamMap, teams, learners);
			mnode.push_back(teams.size());
			lnode.push_back(learners.size());
			sumTeamSizes += (*teiter)->size();
			gtime = (*teiter)->gtime();
			allNumOutcomes.push_back((*teiter)->numOutcomes(_TRAIN_PHASE));

			for (int i = 0; i < 3; i++){
				meanOutcome[i] = (*teiter)->getMeanOutcome(i, _TRAIN_PHASE,MEAN_OUT_PROP);
				meanMeanOutcome[i] += meanOutcome[i];

				if(meanOutcome[i] > maxMeanOutcome[i]){
					maxMeanOutcome[i] = meanOutcome[i];
					maxMeanGtime[i] = (*teiter)->gtime();
					numOutcomesForMaxMean[i] = (*teiter)->numOutcomes(_TRAIN_PHASE);
					maxMeanSize[i] = (*teiter)->size();
				}
				if(meanOutcome[i] < minMeanOutcome[i]){
					minMeanOutcome[i] = meanOutcome[i];
					minMeanGtime[i] = (*teiter)->gtime();
					numOutcomesForMinMean[i] = (*teiter)->numOutcomes(_TRAIN_PHASE);
					minMeanSize[i] = (*teiter)->size();
				}
			}
			if (gtime < minGtime)
				minGtime = gtime;
			meanAge += t-gtime;

			if ((*teiter)->score() > (*teiter)->parentScore())
				meanChildUp++;
		}
	}

	sort(msize.begin(), msize.end());
	sort(mnode.begin(), mnode.end());

	oss << "sbbHP::statsRoot seed " << _seed << " t " << t << " lev " << level;
	oss << " Lsize " << _L.size();
	oss << " msize " << msize[0] << " " << msize[mq1] << " " << msize[mq2] << " " << msize[mq3] << " " << msize.back();
	oss << " mnode " << mnode[0] << " " << mnode[mq1] << " " << mnode[mq2] << " " << mnode[mq3] << " " << mnode.back();
	oss << " lnode " << lnode[0] << " " << lnode[lnode.size()*0.25] << " " << lnode[lnode.size()*0.5] << " " << lnode[lnode.size()*0.75] << " " << lnode.back();

	oss << " meanMeanOut"; for (int i=0; i<3; i++) oss << " " << meanMeanOutcome[i]/_M.size();

	oss << " maxMeanOut"; for (int i=0; i<3; i++) oss << " " << maxMeanOutcome[i];
	oss << " maxMeanAge"; for (int i=0; i<3; i++) oss << " " << t - maxMeanGtime[i];
	oss << " numOutcomesForMaxMean"; for (int i=0; i<3; i++) oss << " " << numOutcomesForMaxMean[i];
	oss << " maxMeanSize"; for (int i=0; i<3; i++) oss << " " << maxMeanSize[i];

	oss << " minMeanOut"; for (int i=0; i<3; i++) oss << " " << minMeanOutcome[i];
	oss << " minMeanAge"; for (int i=0; i<3; i++) oss << " " << t - minMeanGtime[i];
	oss << " numOutcomesForMinMean"; for (int i=0; i<3; i++) oss << " " << numOutcomesForMinMean[i];
	oss << " minMeanSize"; for (int i=0; i<3; i++) oss << " " << minMeanSize[i];

	oss << " maxAge " << t - minGtime;
	oss << " meanAge " << meanAge/_M.size();
	oss << " meanChildUp " << meanChildUp/_M.size();
	oss << " allNumOutcomes " << vecToStr(allNumOutcomes);
	oss << endl;

	cout << oss.str();
	oss.str("");
}

/********************************************************************************************/
void sbbHP::statsRoot(long t,
		long level)
{
	oss.str("");
	int sumTeamSizes = 0;
	int nrefs = 0;
	vector <int> allNumOutcomes;

	/* Quartiles for team sizes. */
	vector < int > msize;
	int mq1 = (int) (_M.size() * 0.25);
	int mq2 = (int) (_M.size() * 0.5);
	int mq3 = (int) (_M.size() * 0.75);

	/* Team node counts. */

	/* Quartiles for team ref counts, counting references to each learner. */
	vector < int > lrefs;
	vector < int > lsize;
	vector < int > lesize;
	int lrq1 = (int) (_L.size() * 0.25);
	int lrq2 = (int) (_L.size() * 0.5);
	int lrq3 = (int) (_L.size() * 0.75);

	//set < point * > :: iterator poiter;
	set < learner * > :: iterator leiter;
	set < team *, teamIdComp > :: iterator teiter;

	/* Mean outcome for a team. */
	double meanOutcome[3];

	double meanChildUp = 0;

	double maxMeanOutcome[3]={0,0,0};
	double meanMeanOutcome[3]={0,0,0};
	double minMeanOutcome[3]={HUGE_VAL,HUGE_VAL,HUGE_VAL};
	int numOutcomesForMaxMean[3];
	int numOutcomesForMinMean[3];
	int maxMeanSize[3];
	int minMeanSize[3];
	long maxMeanGtime[3];
	long minMeanGtime[3];

	long gtime = 0;

	long minGtime = HUGE_VAL;
	double meanAge = 0;

	vector < double > state;

	vector < double > outcomes;
	map < point *, vector < short > * > dist;
	map < point *, vector < short > * > :: iterator diiter;

	set < team *, teamIdComp > :: iterator teiter1, teiter2;
	set < learner * > lset1, lset2, linter;
	int i1, i2;
	map < int, int > olaphist; /* Overlap histogram. */

	oss << "sbbHP::symStat lrefs";
	for(leiter = _L.begin(); leiter != _L.end(); leiter++)
	{
		nrefs += (*leiter)->refs();
		lrefs.push_back((*leiter)->refs());
		lsize.push_back((*leiter)->size());
		lesize.push_back((*leiter)->esize());

		oss << " " << (*leiter)->id() << ":" << (*leiter)->refs();
	}
	oss << endl;

	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
	{
		msize.push_back((*teiter)->size());
		sumTeamSizes += (*teiter)->size();
		gtime = (*teiter)->gtime();
		allNumOutcomes.push_back((*teiter)->numOutcomes(_TRAIN_PHASE));

		for (int i = 0; i < 3; i++){
			meanOutcome[i] = (*teiter)->getMeanOutcome(i, _TRAIN_PHASE,MEAN_OUT_PROP);
			meanMeanOutcome[i] += meanOutcome[i];

			if(meanOutcome[i] > maxMeanOutcome[i]){
				maxMeanOutcome[i] = meanOutcome[i];
				maxMeanGtime[i] = (*teiter)->gtime();
				numOutcomesForMaxMean[i] = (*teiter)->numOutcomes(_TRAIN_PHASE);
				maxMeanSize[i] = (*teiter)->size();
			}
			if(meanOutcome[i] < minMeanOutcome[i]){
				minMeanOutcome[i] = meanOutcome[i];
				minMeanGtime[i] = (*teiter)->gtime();
				numOutcomesForMinMean[i] = (*teiter)->numOutcomes(_TRAIN_PHASE);
				minMeanSize[i] = (*teiter)->size();
			}
		}
		if (gtime < minGtime)
			minGtime = gtime;
		meanAge += t-gtime;

		if ((*teiter)->score() > (*teiter)->parentScore())
			meanChildUp++;
	}

	sort(msize.begin(), msize.end());
	sort(lrefs.begin(), lrefs.end());
	sort(lsize.begin(), lsize.end());
	sort(lesize.begin(), lesize.end());

	oss << "sbbHP::stats seed " << _seed << " t " << t << " lev " << level;
	oss << " mdom " << _mdom;
	oss << " pdom " << _pdom;
	oss << " Lsize " << _L.size();
	oss << " msize " << msize[0] << " " << msize[mq1] << " " << msize[mq2] << " " << msize[mq3] << " " << msize.back();
	oss << " lrefs " << lrefs[0] << " " << lrefs[lrq1] << " " << lrefs[lrq2] << " " << lrefs[lrq3] << " " << lrefs.back();
	oss << " lsize " << lsize[0] << " " << lsize[lrq1] << " " << lsize[lrq2] << " " << lsize[lrq3] << " " << lsize.back();
	oss << " lesize " << lesize[0] << " " << lesize[lrq1] << " " << lesize[lrq2] << " " << lesize[lrq3] << " " << lesize.back();

	oss << " meanMeanOut"; for (int i=0; i<3; i++) oss << " " << meanMeanOutcome[i]/_M.size();

	oss << " maxMeanOut"; for (int i=0; i<3; i++) oss << " " << maxMeanOutcome[i];
	oss << " maxMeanAge"; for (int i=0; i<3; i++) oss << " " << t - maxMeanGtime[i];
	oss << " numOutcomesForMaxMean"; for (int i=0; i<3; i++) oss << " " << numOutcomesForMaxMean[i];
	oss << " maxMeanSize"; for (int i=0; i<3; i++) oss << " " << maxMeanSize[i];

	oss << " minMeanOut"; for (int i=0; i<3; i++) oss << " " << minMeanOutcome[i];
	oss << " minMeanAge"; for (int i=0; i<3; i++) oss << " " << t - minMeanGtime[i];
	oss << " numOutcomesForMinMean"; for (int i=0; i<3; i++) oss << " " << numOutcomesForMinMean[i];
	oss << " minMeanSize"; for (int i=0; i<3; i++) oss << " " << minMeanSize[i];

	oss << " maxAge " << t - minGtime;
	oss << " simTime " << _simTime/_numActions; //_simTime / numder of players (number of actions)
	oss << " nrefs " << nrefs;
	oss << " meanAge " << meanAge/_M.size();
	oss << " meanChildUp " << meanChildUp/_M.size();
	oss << " allNumOutcomes " << vecToStr(allNumOutcomes);
	oss << endl;

	/* Perform the following check to make sure that the number of
	   references recorded in the learners is actually equal to the sum
	   of the team sizes and that the outcome counts equal the number of
	   points multiplied by the number of teams. */

	//if(sumTeamSizes != nrefs || sumNumOutcomes != (_Msize - _Mgap) * _episodesPerGeneration) //(_Psize - _Pgap))
	if(sumTeamSizes != nrefs)
	{
		//cout <<"sumNumOutcomes " << sumNumOutcomes << " though it'd be " << (_Msize - _Mgap) * _episodesPerGeneration << endl;
		cout << "sumteamsizes " << sumTeamSizes << " nrefs " << nrefs << endl;
		die(__FILE__, __FUNCTION__, __LINE__, "something does not add up");
	}


	/* Team overlap. */

	/* Maps shared learner count to how many teams share that many learners. */

	for(size_t i = 0; i <= _omega; i++)
		olaphist.insert(map < int, int > :: value_type(i, 0));

	oss << "sbbHPImplicit::stats seed " << _seed << " t " << t << " lev " << level;
	oss << " sharedlearners " << _M.size() << " ids";
	for(teiter1 = _M.begin(); teiter1 != _M.end(); teiter1++)
		oss << " " << (*teiter1)->id();
	oss << " matrix";

	for(i1 = 0, teiter1 = _M.begin(); teiter1 != _M.end(); i1++, teiter1++)
	{
		for(i2 = 0, teiter2 = _M.begin(); teiter2 != _M.end(); i2++, teiter2++)
		{
			if(i2 < i1) /* Already considered this pair. */
			{
				oss << " 0";
			}
			else if(i2 > i1) /* Haven't considered this pair yet. */
			{
				lset1.clear();
				lset2.clear();
				linter.clear();

				(*teiter1)->members(&lset1);
				(*teiter2)->members(&lset2);

				set_intersection(lset1.begin(), lset1.end(),
						lset2.begin(), lset2.end(),
						insert_iterator < set < learner * > > (linter, linter.begin()));

				oss << " " << linter.size();

				olaphist[linter.size()]++;
			}
			else /* Same team, i1 == i2. */
			{
				oss << " " << (*teiter1)->size();
			}
		}
	}
	oss << endl;

	oss << "sbbHPImplicit::stats id " << _id << " seed " << _seed << " t " << t << " lev " << level << " olaphist mat";
	for(size_t i = 0; i <= _omega; i++)
		oss << " " << olaphist[i];
	oss << endl;
	cout << oss.str();
	oss.str("");
}

///**********************************************************************************************************/
//void sbbHP::testSymbiontUtilityDistance(){
//	ostringstream o;
//	vector< team* > teams;
//	set < team * , teamIdComp > :: iterator teiter;
//	for(teiter = _M.begin(); teiter != _M.end(); teiter++)
//		teams.push_back(*teiter);
//	for (size_t i = 0; i < teams.size(); i++)
//		for (size_t j = 0; j < teams.size(); j++){
//			double dist = teams[i]->symbiontUtilityDistance(teams[j],_omega);
//		}
//}

/***********************************************************************************************************/
void sbbHP::writeCheckpoint(int phase,ostream& os) const {
	set < team *, teamIdComp > :: iterator teiter, itBegin, teiterEnd;
	set < learner * > :: iterator leiter, leiterEnd;

	os << "seed:" << _seed << endl;

	for(leiter = _L.begin(), leiterEnd = _L.end(); leiter != leiterEnd; leiter++)
		os << (*leiter)->checkpoint();

	for(teiter = _M.begin(), teiterEnd = _M.end(); teiter != teiterEnd; teiter++){
		if (phase == _TEST_PHASE){
			if ((*teiter)->id() == currentChampion->id())
				os << (*teiter)->checkpoint(phase);
		}
		else if (phase == _SINGLE_EVAL_PHASE){
			if ((*teiter)->id() == (*teiterEval)->id())
				os << (*teiter)->checkpoint(phase);
		}
		else
			os << (*teiter)->checkpoint(phase);
	}
}

/***********************************************************************************************************/
void sbbHP::writeEval(int t, int level, int phase){
	ofstream outFile;
	char outputFilenameTmp[80];
	char outputFilename[80];
	//mkdir("evals", S_IRWXU|S_IRGRP|S_IXGRP);
	sprintf(outputFilenameTmp, "evals/tmp.eval.%d.%d.%d.rslt",phase,_id,_seed );
	sprintf(outputFilename, "evals/eval.%d.%d.%d.rslt",phase,_id,_seed );

	if (fileExists(outputFilename))
		rename(outputFilename,outputFilenameTmp);

	outFile.open(outputFilenameTmp, ios::out);

	if (!outFile) {
		cerr << "Can't open eval file write: " << outputFilenameTmp << endl;
		exit(1);
	}
	map < point *, double, pointLexicalLessThan > allOutcomes;
	map < point *, double > :: iterator myoiter;
	vector <double> episodeProfile;
	set < team * > :: iterator teiter, teiterEnd;
	set < learner * > activeMembers;
	set < learner * > :: iterator leiter;

	for(teiter = _M.begin(), teiterEnd = _M.end(); teiter != teiterEnd; teiter++){
		(*teiter)->outcomes(allOutcomes,phase);
		for(myoiter = allOutcomes.begin(); myoiter != allOutcomes.end(); myoiter++){
			(myoiter->first)->behaviouralState(episodeProfile);
			outFile << (*teiter)->id() << ":";
			activeMembers.clear();
			(*teiter)->activeMembers(&activeMembers); /* Get active members. */
			for(leiter = activeMembers.begin(); leiter != activeMembers.end(); leiter++){
				if (leiter != activeMembers.begin())
					outFile << " ";
				outFile << (*leiter)->id();
			}
			outFile << ":" << (myoiter->first)->auxDouble(0) << ":" << (myoiter->first)->auxDouble(1) << ":" << (myoiter->first)->auxDouble(2) << ":" << vecToStr(episodeProfile) << endl;
		}
	}
	outFile.close();
	rename(outputFilenameTmp,outputFilename);
}

/***********************************************************************************************************/
bool sbbHP::writeRunShare(double f){
	ofstream outFile;
	outFile.precision(numeric_limits< double >::digits10+1);
	char outputFilename[80];
	sprintf( outputFilename, "run_share/medianOutcome.%d.rslt",_seed);
	if (fileExists(outputFilename) == false){
		outFile.open(outputFilename, ios::out);
		outFile << f << endl;
		outFile.close();
		return true;
	}
	return false;
}
